<!doctype html>
<meta charset="utf-8" />
<title>Heart → Particle Rose → Text</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block;margin:0 auto;background:#000;touch-action:none}
</style>
<canvas id="cv"></canvas>
<script>
/* ===== 文字與顏色 ===== */
const TEXT = "祝福老媽生日快樂樂樂 happy birthday";
const BG = "#000";
const HEART_COLOR = "#ff1a1a";   // 愛心鮮紅
const PETAL_MAIN   = "#FF88C2";   // 玫瑰主色
const PETAL_EDGE   = "#ff3b3b";   // 玫瑰亮邊
const STEM_GREEN   = "#3ea256";
const LEAF_GREEN   = "#247a34";
const VEIN_GREEN   = "#a7d9a3";

/* ===== 時間（秒） ===== */
const HEART_SEC=3.0, EXPLODE_SEC=1.6, MORPH_SEC=2.6, TEXT_SEC=3.6;

/* ===== 畫布與工具 ===== */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");
function resize(){ cv.width=Math.min(innerWidth,960); cv.height=Math.min(innerHeight,720); }
resize(); addEventListener("resize", resize);
const cx = ()=>cv.width/2, cy=()=>cv.height/2;
const clamp01 = x => x<0?0:x>1?1:x;
const lerp = (a,b,t)=>a+(b-a)*t;
const ease = t => t*t*(3-2*t);          // smoothstep
const rand = (a,b)=>a+Math.random()*(b-a);
const breath = t=>Math.sin(4*t);

/* ===== 狀態 ===== */
const S = {phase:0,t:0,running:true, P:[], T:[]}; // P: 粒子, T: 玫瑰目標

/* ===== 粒子結構 =====
   每顆粒子：{x,y,vx,vy,size, color, tx,ty, tsize,tcolor}
   其中 (tx,ty,tsize,tcolor) 是 morph 目標（玫瑰點） */
function dot(p){
  ctx.fillStyle = p.color;
  ctx.fillRect(p.x|0, p.y|0, p.size, p.size);
}

/* ===== 愛心取樣（點雲） ===== */
function heartXY(t, scale){
  let x = 16*Math.pow(Math.sin(t),3);
  let y = -(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
  x*=scale; y*=scale; return [x+cx(), y+cy()];
}
function buildHeartParticles(N){
  // 自適應密度：手機較少、桌面較多
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const base = Math.floor((cv.width*cv.height)/900) + (isMobile?2200:3800);
  N = N || base;                       // 例如 3600~7000 左右
  const scale = Math.min(cv.width,cv.height)/48;

  const pts=[];
  // 邊界：60%
  for(let i=0;i<N*0.6;i++){
    const tt=Math.random()*Math.PI*2;
    pts.push([...heartXY(tt,scale), 2, HEART_COLOR]);
  }
  // 內部：40%（指數分佈向中心）
  for(let i=0;i<N*0.4;i++){
    const tt=Math.random()*Math.PI*2;
    const [x,y]=heartXY(tt,scale);
    const r=-0.12*Math.log(Math.max(Math.random(),1e-9));
    pts.push([ x+(cx()-x)*r, y+(cy()-y)*r, 1, HEART_COLOR ]);
  }

  S.P = pts.map(([x,y,size,color])=>{
    let vx=x-cx(), vy=y-cy(), d=Math.hypot(vx,vy)+1e-6;
    const speed=2.0+1.2*(d/180)+Math.random()*0.6;
    return {x,y,vx:vx/d*speed,vy:vy/d*speed,size,color,tx:x,ty:y,tsize:size,tcolor:color};
  });
}
/* ===== 玫瑰目標點雲（粒子版） ===== */
function buildRoseTargets(){
  const targets=[];
  const R = Math.min(cv.width,cv.height)/3.05;
  const x0=cx(), y0=cy();

  // 梗（更密）
  const stemN = 380;
  for(let i=0;i<stemN;i++){
    const t=i/stemN, Y=y0+t*180, X=x0+0.18*180*t*Math.sin((180*t)/35);
    targets.push([X,Y,1,STEM_GREEN]);
  }

  // 葉（雙層填充 + 葉脈）
  function leaf(bx,by,len,ang){
    const steps=240;
    for(let i=0;i<=steps;i++){
      const t=i/steps, r=len*Math.sin(t*Math.PI);
      const a=ang+(t-0.5)*0.7;
      const X=bx+r*Math.cos(a), Y=by+r*Math.sin(a);
      targets.push([X,Y,1,LEAF_GREEN]);
      // 內部填充幾條平行紋理
      if(i%4===0){
        for(let u=0.15;u<=0.85;u+=0.35){
          const rr=r*u, Xa=bx+rr*Math.cos(a), Ya=by+rr*Math.sin(a);
          targets.push([Xa,Ya,1,LEAF_GREEN]);
        }
      }
    }
    for(let t=0;t<=1;t+=1/26){
      const X=bx+(len*0.96*t)*Math.cos(ang), Y=by+(len*0.96*t)*Math.sin(ang);
      targets.push([X,Y,1,VEIN_GREEN]);
    }
  }
  leaf(x0+R*0.18, y0+R*0.60, 54, 2.85);
  leaf(x0-R*0.26, y0+R*0.73, 64, 2.50);

  // 花瓣：多 ring + 厚度掃描 + 內部填充
  const k=6;                              // 玫瑰花瓣頻率
  const rings=[1.35,1.18,1.02,0.88,0.74,0.60];
  const angStep = 0.4 * Math.PI/180;      // 角度步距（越小越密）
  const thickSteps = 10;                  // 厚度層數
  for(const ring of rings){
    for(let th=0; th<Math.PI*2; th+=angStep){
      const rEdge = R*ring*Math.abs(Math.sin(k*th));
      // 厚度：從 70%~108% 掃描
      for(let j=0;j<thickSteps;j++){
        const t=j/(thickSteps-1);
        const rr = rEdge*(0.72 + 0.36*t);
        const x = x0 + rr*Math.cos(th), y = y0 + rr*Math.sin(th);
        const col = (ring>=1.0? PETAL_MAIN : PETAL_EDGE);
        targets.push([x,y,1,col]);
      }
      // 內部隨機填充 2 點（讓花瓣看起來「有肉」）
      for(let m=0;m<2;m++){
        const u=Math.sqrt(Math.random());        // 偏向中心
        const rr = rEdge*u;
        const x = x0 + rr*Math.cos(th), y = y0 + rr*Math.sin(th);
        targets.push([x,y,1, PETAL_MAIN]);
      }
    }
  }

  // 花心
  for(let a=0;a<360;a+=2){
    const t=a*Math.PI/180, rr=13;
    targets.push([x0+rr*Math.cos(t), y0+rr*Math.sin(t), 1, PETAL_EDGE]);
  }

  // 對齊數量：若玫瑰點 > 粒子數，增加心的粒子；反之截斷玫瑰點
  if(targets.length > S.P.length){
    // 擴心顆數：再補一些內部粒子（不需要重建速度）
    const need = targets.length - S.P.length;
    for(let i=0;i<need;i++){
      const tt=Math.random()*Math.PI*2;
      const [x,y]=heartXY(tt, Math.min(cv.width,cv.height)/48);
      S.P.push({x,y,vx:0,vy:0,size:1,color:HEART_COLOR,tx:x,ty:y,tsize:1,tcolor:HEART_COLOR});
    }
  }else if(targets.length < S.P.length){
    S.P.length = targets.length;
  }

  // 綁定 morph 目標
  for(let i=0;i<S.P.length;i++){
    const p=S.P[i], t=targets[i];
    p.tx=t[0]; p.ty=t[1]; p.tsize=t[2]; p.tcolor=t[3];
  }
  S.T = targets;
}


/* ===== 初始化 ===== */
function init(){
  buildHeartParticles();
  buildRoseTargets(S.P.length); // 先準備目標
}
init();

/* ===== 各階段繪製 ===== */
function drawHeartBeat(now){
  const k=0.12*breath(now);
  for(const p of S.P){
    const dx=p.x-cx(), dy=p.y-cy();
    const x = p.x - k*dx, y = p.y - k*dy;
    ctx.fillStyle=p.color;
    ctx.fillRect(x|0, y|0, p.size, p.size);
  }
}
function drawExplode(prog){
  for(const p of S.P){
    const scale = 1 + 1.1*prog;
    let x = cx() + (p.x-cx())*scale + p.vx*(prog*20);
    let y = cy() + (p.y-cy())*scale + p.vy*(prog*20);
    ctx.fillStyle=p.color;
    ctx.fillRect(x|0, y|0, p.size, p.size);
  }
}
function drawMorph(prog){
  // 在 morph 開始時，記錄「爆散後位置」當起點：將第一次呼叫時把 p.sx, p.sy 帶入
  if(!S.hasOwnProperty("_morphInit")){
    for(const p of S.P){
      p.sx = cx() + (p.x-cx())*2.1 + p.vx*(20); // 取爆散終點的近似
      p.sy = cy() + (p.y-cy())*2.1 + p.vy*(20);
    }
    S._morphInit = true;
  }
  const t = ease(clamp01(prog));
  // 微星點背景
  for(let i=0;i<80;i++) ctx.fillStyle="#151515", ctx.fillRect(rand(0,cv.width), rand(0,cv.height), 1, 1);

  for(const p of S.P){
    const jx = rand(-0.8,0.8)*(1-t); // 抖動遞減
    const jy = rand(-0.8,0.8)*(1-t);

    const x = lerp(p.sx, p.tx, t) + jx;
    const y = lerp(p.sy, p.ty, t) + jy;
    const s = Math.max(1, Math.round(lerp(p.size, p.tsize, t)));
    // 漸換顏色：前期維持心紅，後期轉為玫瑰色
    const useColor = (t<0.55)?p.color:p.tcolor;
    ctx.fillStyle=useColor;
    ctx.fillRect(x|0, y|0, s, s);
  }
}
function drawText(now, tSec){
  // 玫瑰保持粒子狀的最終形
  for(const p of S.P){
    ctx.fillStyle=p.tcolor;
    ctx.fillRect(p.tx|0, p.ty|0, p.tsize, p.tsize);
  }
  const fs = Math.floor(32*(1+0.03*Math.sin(now*2*Math.PI)));
  const n = Math.min(TEXT.length, Math.floor(tSec*15)); // ~15字/秒
  const shown = TEXT.slice(0,n);
  ctx.font=`bold ${fs}px Helvetica, Arial, Noto Sans TC, sans-serif`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillStyle="#222"; ctx.fillText(shown, cx()+2, cy()+2);
  ctx.fillStyle="#fff"; ctx.fillText(shown, cx(), cy());
}

/* ===== 主循環 ===== */
let last=performance.now()/1000;
function tick(nowMs){
  const now=nowMs/1000, dt=Math.min(0.05, now-last); last=now;
  if(S.running && S.phase!==4) S.t += dt;

  ctx.fillStyle=BG; ctx.fillRect(0,0,cv.width,cv.height);

  if(S.phase===0){
    drawHeartBeat(now);
    if(S.t>=HEART_SEC){ S.phase=1; S.t=0; }
  }else if(S.phase===1){
    drawExplode(Math.min(1,S.t/EXPLODE_SEC));
    if(S.t>=EXPLODE_SEC){ S.phase=2; S.t=0; }
  }else if(S.phase===2){
    drawMorph(Math.min(1,S.t/MORPH_SEC));
    if(S.t>=MORPH_SEC){ S.phase=3; S.t=0; }
  }else if(S.phase===3){
    drawText(now, S.t);
    if(S.t>=TEXT_SEC){ S.phase=4; }
  }else{
    // 停在最終畫面
    drawText(now, TEXT_SEC);
  }

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* 互動：點擊/空白 暫停、R 重播 */
addEventListener("click", ()=>S.running=!S.running);
addEventListener("keydown", e=>{
  if(e.key===" ") S.running=!S.running;
  if(e.key.toLowerCase()==="r"){
    S.phase=0; S.t=0; S._morphInit=false;
    init();
  }
});
</script>
